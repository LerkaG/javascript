<!DOCTYPE html>
<html lang='en'>
<head>
	<meta charset='UTF-8'>
	<title>Cтиль JS и правила кодирования. Лучшие практики. Распространенные ошибки </title>
	<link href="style.css" rel="stylesheet">
</head>
<body>
	<a href="javascript:scroll(0,10000)" >
		<button class="btn">⇩</button>
	</a>
	<a href="javascript:scroll(0,0)" title="наверх">
		<button class="btn_down">⇧</button>
	</a>
	<b id="link"></b> 

	<h1>Руководство по стилю JS и правила кодирования</h1>

	<h2>Соглашения о кодировании JavaScript</h2>
	Соглашения о кодировании - это рекомендации по стилю программирования. 
	<br>ПРИМЕР
	<pre>
		Обычно они охватывают:
		- Правила именования и объявления для переменных и функций.
		- Правила использования пробелов, отступов и комментариев.
		- Практики и принципы программирования

		Соглашения о кодировании безопасного качества :
		- Улучшает читаемость кода
		- Упростите обслуживание кода
		- Соглашения могут быть задокументированными правилами, которым должны следовать команды
	</pre>

	<h2>Пространства вокруг операторов</h2>
	Всегда ставьте пробелы вокруг операторов <b>(= + - * /)</b> и после запятых:
	<br>ПРИМЕР
	<pre>
		var x = y + z;
		var values = ["Volvo", "Saab", "Fiat"];
	</pre>

	<h2>Правила заявления</h2>
		Общие правила для простых утверждений:	Всегда заканчивайте простое утверждение точкой с запятой. <br>
		Общие правила составления сложных (составных) утверждений: Не заканчивайте сложное утверждение точкой с запятой.
	<br>ПРИМЕР
	<pre>
		<b>Простые утверждения</b>
		var values = ["Volvo", "Saab", "Fiat"];
		var person = {
		  firstName: "John",
		  lastName: "Doe",
		  age: 50,
		  eyeColor: "blue"
		};

		<b>Cложные (составные) утверждения</b>
		Функции:
		function toCelsius(fahrenheit) {
		  return (5 / 9) * (fahrenheit - 32);
		}

		Циклы:
		for (i = 0; i < 5; i++) {
		  x += i;
		}
		
		Условные операторы:
		if (time < 20) {
		  greeting = "Good day";
		} else {
		  greeting = "Good night";
		}
	</pre>

	<h2>Правила объекта</h2>
		Общие правила для определений объектов: <br>
		- Используйте кавычки вокруг строковых значений, а не вокруг числовых значений. <br>
		- Не добавляйте запятую после последней пары "свойство-значение". <br>
		- Всегда заканчивайте определение объекта точкой с запятой. <br>
		Короткие объекты можно записывать в сжатом виде в одну строку, используя только пробелы между свойствами
	<br>ПРИМЕР
	<pre>
		var person = {first_name:"John", last_name:"Doe", age:50};
	</pre>

	<h2>Длина линии <80</h2>
	Для удобства чтения нужно избегать строк длиной более 80 символов. <br>
	Если оператор JS не помещается в одной строке, лучше всего его разорвать после оператора или запятой.
	<br>ПРИМЕР
	<pre>
		document.getElementById("demo").innerHTML =
		"Hello Dolly.";
	</pre>

	<h2>Соглашения об именах</h2>
	Всегда использовать одно и то же соглашение об именах для всего кода. <br>
	Имена переменных и функций, Глобальных переменных, Констант <br>
	В именах JS нельзя использовать дефисы, они могут быть ошибочно приняты за попытки вычитания. <br>
	Не начинать имена со знака <b>$</b> - это приведет к конфликту со многими именами библиотек JS.

	<h2>Загрузка JS в HTML</h2>
	Использовать простой синтаксис для загрузки внешних скриптов (атрибут <b>type</b> не нужен):
	<br>ПРИМЕР
	<pre>
		< script src="myscript.js">< /script>
	</pre>

	<h2>Доступ к HTML-элементам</h2>
	Следствие использования «неопрятных» стилей HTML может привести к ошибкам JavaScript.

	<br>ПРИМЕР
	<pre>
		Эти два оператора JS дадут разные результаты:
		var obj = getElementById("Demo")
		var obj = getElementById("demo")
	</pre>
	
	<h2>Производительность</h2>
	Соглашения о кодировании не используются компьютерами. Большинство правил мало влияют на выполнение программ. <br>
	В маленьких скриптах отступы и лишние пробелы не имеют значения. <br>
	Для кода, находящегося в разработке, предпочтение следует отдавать удобочитаемости. <br>
	Большие производственные скрипты следует минимизировать.  


	<h1>Лучшие практики JS</h1>
	Избегайте <b>глобальных переменных</b>, избегайте <b>new</b>, избегайте <b>==</b>, избегайте <b>eval()</b>

	<h2>Избегать глобальных переменных</h2>
	Свести к минимуму использование глобальных переменных. Сюда входят все типы данных, объекты и функции.
	Вместо этого использоваьб локальные переменные и узнайть, как использовать замыкания.

	<h2>Всегда объявлять локальные переменные</h2>
	Все переменные, используемые в функции, должны быть объявлены как локальные переменные. <br>
	Локальные переменные должны быть объявлены с <b>var</b> ключевым словом или <b>let</b> ключевым словом, иначе они станут глобальными переменными. <br>
	Строгий режим не допускает необъявленных переменных.
	
	<h2>Объявления сверху</h2>
	Рекомендуется размещать все объявления в верхней части каждого скрипта или функции. <br>
	- Дайте более чистый код <br>
	- Обеспечьте единое место для поиска локальных переменных <br>
	- Упростите избежание нежелательных (подразумеваемых) глобальных переменных <br>
	- Уменьшите вероятность нежелательных повторных деклараций
	<br>ПРИМЕР
	<pre>
		var first_name, last_name, price, discount, full_price;
		first_name = "John";
		last_name  = "Doe";
		price = 19.90;
		discount = 0.10;
		full_price = price - discount;

		Это также касается переменных цикла:
		var i;
		for (i = 0; i < 5; i++){}
	</pre>
	
	<h2>Инициализировать переменные</h2>
	Это хорошая практика кодирования - инициализировать переменные при их объявлении. <br>
	- Дайте более чистый код <br>
	- Обеспечьте единое место для инициализации переменных <br>
	- Избегайте неопределенных значений <br>
	Инициализация переменных дает представление о предполагаемом использовании (и предполагаемом типе данных).
	<br>ПРИМЕР
	<pre>
		var first_name = "",
		last_name = "",
		price = 0,
		discount = 0,
		full_price = 0,
		my_array = [],
		my_object = {};
	</pre>
	
	<h2>Никогда не объявляйте числовые, строковые или логические объекты</h2>
	Всегда обрабатывайте числа, строки или логические значения как примитивные значения. Не как объекты. <br>
	Объявление этих типов как объектов снижает скорость выполнения и вызывает неприятные побочные эффекты:
	<br>ПРИМЕР
	<pre>
		var x = "John";             
		var y = new String("John");
		(x === y) // <b>false</b>

		var x = new String("John");             
		var y = new String("John");
		(x == y) // <b>false</b>
	</pre>
	
	<h2>Не использовать new Object()</h2>
	Используйте <b>{}</b> вместо <b>new Object()</b> <br>
	Используйте <b>""</b> вместо <b>new String()</b> <br>
	Используйте <b>0</b> вместо <b>new Number()</b> <br>
	Используйте <b>false</b> вместо <b>new Boolean()</b> <br>
	Используйте <b>[]</b> вместо <b>new Array()</b> <br>
	Используйте <b>/()/</b> вместо <b>new RegExp()</b> <br>
	Используйте <b>function (){}</b> вместо <b>new Function() </b>
	<br>ПРИМЕР
	<pre>
		var x1 = {};           // <b id="style_0"></b>
		var x2 = "";           // <b id="style_1"></b>
		var x3 = 0;            // <b id="style_2"></b>
		var x4 = false;        // <b id="style_3"></b>
		var x5 = [];           // <b id="style_4"></b>
		var x6 = /()/;         // <b id="style_5"></b>
		var x7 = function(){}; // <b id="style_6"></b>
	</pre>
	
	<h2>Остерегайтесь автоматического преобразования типов</h2>
	Помните, что числа могут случайно быть преобразованы в строки или <b>NaN</b>(не число). JS слабо типизирован. <br>Переменная может содержать разные типы данных, и переменная может изменять свой тип данных:
	<br>ПРИМЕР
	<pre>
		var x = "Hello"; // String
		x = 5;           // Number

		При выполнении математических операций JS может преобразовывать числа в строки:
		var x = 5 + "7"; //57

		Вычитание строки из строки не приводит к ошибке, но возвращает <b>NaN</b>(не число):
		"hello" - "hello"; // <b id="style_7"></b>
	</pre>
	
	<h2>Используйте === Сравнение</h2>
	 <b>==</b> Оператор сравнения всегда преобразуется (в соответствующие типы) перед сравнением. <br>
	<b>===</b> Oператор вызывает сравнение значений и типа:
	<br>ПРИМЕР
	<pre>
		x = (0 == "");    // <b>true</b>
		x = (1 == "1");   // <b>true</b>
		x = (1 == true);  // <b>true</b>

		x = (0 === "");   // <b>false</b>
		x = (1 === "1");  // <b>false</b>
		x = (1 === true); // <b>false</b>
	</pre>
	
	<h2>Использовать значения параметров по умолчанию</h2>
	Если функция вызывается с отсутствующим аргументом, значение отсутствующего аргумента устанавливается равным <b>undefined</b>. <br>
	Неопределенные значения могут нарушить ваш код. Присваивать аргументам значения по умолчанию - хорошая привычка.
	<br>ПРИМЕР
	<pre>
		function func_style_0(x, y) {
		   if (y === undefined) {
		      y = 0;
		   }
		   return x * y;
		}
		func_style_0(4); // <b id="style_8"></b>
	</pre>

	<h2>Завершите свои переключатели настройками по умолчанию</h2>
	Всегда заканчивайте свои <b>switch</b> утверждения расширением <b>default</b>. Даже если вы думаете, что в этом нет необходимости.
	<br>ПРИМЕР
	<pre>
		switch (new Date().getDay()) {
		 case 0:
		   day = "Sunday";
		   break;
		 case 1:
		   day = "Monday";
		   break;
		 case 2:
		   day = "Thuesday";
		   break;
		 case 3:
		   day = "Wednesday";
		   break;
		 case 4:
		   day = "Thursday";
		   break;
		 case 5:
		   day = "Friday";
		   break;
		 case 6:
		   day = "Saturday";
		   break;
		 default:
		   day = "Unknown"
		} // <b id="style_9"></b>
	</pre>

	<h2>Избегайте использования eval()</h2>
	<b>eval()</b> - Функция используется для запуска текст в качестве кода. Практически во всех случаях нет необходимости использовать его. <br>
	Поскольку он позволяет запускать произвольный код, он также представляет проблему безопасности.

	<script>
		var first_name, last_name, price, discount, full_price;
		first_name = "John";
		last_name  = "Doe";
		price = 19.90;
		discount = 0.10;
		full_price = price - discount;

		var i;
		for (i = 0; i < 5; i++){}

		var x1 = {};
		var x2 = "";
		var x3 = 0;
		var x4 = false;
		var x5 = [];
		var x6 = /()/;
		var x7 = function(){};
		document.getElementById("style_0").innerHTML = typeof x1;
		document.getElementById("style_1").innerHTML = typeof x2;
		document.getElementById("style_2").innerHTML = typeof x3;
		document.getElementById("style_3").innerHTML = typeof x4;
		document.getElementById("style_4").innerHTML = typeof x5;
		document.getElementById("style_5").innerHTML = typeof x6;
		document.getElementById("style_6").innerHTML = typeof x7;
		
		document.getElementById("style_7").innerHTML = "hello" - "hello";

		function func_style_0(x, y) {
			if (y === undefined) {
				y = 0;
			}
			return x * y;
		}
		document.getElementById("style_8").innerHTML = func_style_0(4);

		switch (new Date().getDay()) {
			case 0:
				day = "Sunday";
				break;
			case 1:
				day = "Monday";
				break;
			case 2:
				day = "Thuesday";
				break;
			case 3:
				day = "Wednesday";
				break;
			case 4:
				day = "Thursday";
				break;
			case 5:
				day = "Friday";
				break;
			case 6:
				day = "Saturday";
				break;
			default:
				day = "Unknown"
		}
		document.getElementById("style_9").innerHTML = "Today is " + day;
	</script>

	<h1>Распространенные ошибки JS</h1>

	<h2>Случайное использование оператора присваивания</h2>
	Программы могут генерировать неожиданные результаты, если случайно использовать оператор присваивания <b>=</b> вместо оператора сравнения <b>==</b> в операторе  <b>if</b>. <br>
	Присвоение всегда возвращает значение присваивания. 	
	<br>ПРИМЕР
	<pre>
		Этот <b>if</b> оператор возвращает <b>false</b>, потому что x не равно 10:
		var x = 0;
		Boolean(x == 10); // <b id="error_0"></b>

		Этот <b>if</b> оператор возвращается <b>true</b>, потому что 10 верно:
		var x = 0;
		Boolean(x = 10);  // <b id="error_1"></b>

		Этот <b>if</b> оператор возвращается <b>false</b>, потому что 0 - ложь:
		var x = 0;
		Boolean(x = 0);  // <b id="error_2"></b>
	</pre>

	<h2>Ожидая бесполезного сравнения</h2>
	При обычном сравнении тип данных не имеет значения. В строгом сравнении тип данных имеет значение. <br>
	B <b>switch</b> операторах используется строгое сравнение.
	<br>ПРИМЕР
	<pre>
		var x = 10;
		var y = "10";

		Обычноe сравнение. <b>if</b> утверждение возвращает истину:
		(x == y); // <b id="error_3"></b>

		Строгое сравнение. Этот <b>if</b> оператор возвращает ложь:
		(x === y); // <b id="error_4"></b>
		
		Этот <b>case switch</b> отобразит предупреждение:
		switch (x) {
		   case 10: alert("hi")
		}

		Этот <b>case switch</b> не будет отображать предупреждение:
		switch (x) {
		   case "10": alert("hi")
		}
	</pre>

	<h2>Запутывающее сложение и конкатенация</h2>
	<b>Сложение</b> касается сложения чисел. <b>Конкатенация</b> - это добавление строк.
	Обе операции используют один и тот же оператор <b>+</b>. <br>
	Из-за этого добавление числа в виде числа приведет к другому результату, чем добавление числа в виде строки:
	<br>ПРИМЕР
	<pre>
		var x = 10 + 5;   // <b>15</b>
		var x = 10 + "5"; // <b>"105"</b>
	</pre>	

	<h2>Непонимание поплавков</h2>
	Все числа в JS хранятся как 64-битные числа с плавающей запятой (Floats). <br>
	Все языки программирования, испытывают трудности с точными значениями с плавающей запятой:
	<br>ПРИМЕР
	<pre>
		var x = 0.1;
		var y = 0.2;
		x + y; // <b id="error_5"></b>

		Чтобы решить указанную выше проблему, помогает умножать и делить:
		var z = (x * 10 + y * 10)/ 10;
		z; // <b id="error_6"></b>

	</pre>

	<h2>Разрыв строки JS</h2>
	Можно разбить инструкцию на две строки. Но разбить оператор в середине строки не получится. <br>
	использовать "обратную косую черту", если нужно разбить оператор в строке:
	<br>ПРИМЕР
	<pre>
		var x = "Hello \
		World!";
	</pre>

	<h2>Нарушение заявления о возврате</h2>
	По умолчанию в JS оператор автоматически закрывается в конце строки. <br>
	<b>return</b> нельзя разбивать на две строки, поскольку это утверждение является полным. <br>
	Закрывающие/завершающие операторы с <b>;</b> не являются обязательными в JS.
	<br>ПРИМЕР
	<pre>
		Из-за этого эти два примера вернут один и тот же результат:
		1. function func_0(a) {
		   var power = 10
		   return a * power
		 }

		2. function func_0(a) {
		   var power = 10<b>;</b>
		   return a * power<b>;</b>
		 }

		Также можно разбить инструкцию на две строки. Из-за этого пример 3 также вернет тот же результат:
		3. function func_0(a) {
		   var 
		   power = 10<b>;</b>
		   return a * power<b>;</b>
		 }

		func_0(2);  // <b id="error_7"></b>
	</pre>

	<h2>Доступ к массивам с помощью именованных индексов</h2>
	Массивы с именованными индексами называются ассоциативными массивами (или хэшами). <br>
	JS не поддерживает массивы с именованными индексами, массивы используют нумерованные индексы. <br>
	Если использовать именованный индекс, при доступе к массиву JS переопределит массив на стандартный объект.
	<br>ПРИМЕР
	<pre>
		var person = [];
		person[0] = "John";
		person[1] = "Doe";
		person[2] = 46;
		person.length; //<b id="array_0"></b>
		person[0]; //<b id="array_1"></b>

		В JS объекты используют именованные индексы. После автоматического переопределения
		методы и свойства массива будут давать неопределенные или неверные результаты:
		var person = [];
		person["first_name"] = "John";
		person["last_name"] = "Doe";
		person["age"] = 46;
		person.length; //<b id="array_2"></b>
		person["last_name"]; //<b id="array_3"></b>
		person[1]; //<b id="array_4"></b>
	</pre>

	<h2>Завершение определений запятой</h2>
	Завершающие запятые в определениях объектов и массивов допустимы в ECMAScript 5. <br>
	<b>JSON</b> не допускает конечных запятых.
	<br>ПРИМЕР
	<pre>
		person = {first_name:"John", last_name:"Doe", age:46,} // object
		points = [40, 100, 1, 5, 25, 10,]; //array

		person = {first_name:"John", last_name:"Doe", age:46} // <b>JSON</b>
		points = [40, 100, 1, 5, 25, 10]; // <b>JSON</b>
	</pre>

	<h2>Неопределенный не равен нулю</h2>
	Объекты, переменные, свойства и методы JS могут быть <b>undefined</b>. Пустые объекты JS могут иметь значение <b>null</b>. <br>
	Можно проверить, существует ли объект, проверив его тип <b>undefined</b>:
	<br>ПРИМЕР
	<pre>
		typeof object === "undefined"; //<b id="test_type_0"></b>

		Нельзя проверить, есть ли объект <b>null</b>, потому что это вызовет ошибку, если объект <b>undefined</b>:
		typeof object === "null"; //<b id="test_type_1"></b>

		Чтобы решить эту проблему, нужно проверить, нет ли объекта <b>undefined</b> или <b>null</b>.
		object !== "undefined" && typeof object !== null; //<b id="test_type_2"></b>
	</pre>
	<code><ul> <b id=''></b> </ul></code> <br>

	<script>
		var x = 0;
		document.getElementById("error_0").innerHTML = Boolean(x == 10);
		document.getElementById("error_1").innerHTML = Boolean(x = 10);
		document.getElementById("error_2").innerHTML = Boolean(x = 0);

		var x = 10;
		var y = "10";
		document.getElementById("error_3").innerHTML = Boolean(x == y);
		document.getElementById("error_4").innerHTML = Boolean(x === y);

		switch (x) {
			case 11: alert("hi")
		}
		switch (x) {
			case "10": alert("hi")
		}

		var x = 0.1;
		var y = 0.2;
		document.getElementById("error_5").innerHTML = x + y;

		var z = (x * 10 + y * 10)/10;
		document.getElementById("error_6").innerHTML = z;

		function func_0(a) {
			var power = 10;
			return a * power;
		}
		document.getElementById("error_7").innerHTML = func_0(2);

		var person = [];
		person[0] = "John";
		person[1] = "Doe";
		person[2] = 46;
		document.getElementById("array_0").innerHTML = person.length;
		document.getElementById("array_1").innerHTML = person[0];

		var person = [];
		person["first_name"] = "John";
		person["last_name"] = "Doe";
		person["age"] = 46;
		document.getElementById("array_2").innerHTML = person.length;
		document.getElementById("array_3").innerHTML = person["last_name"];
		document.getElementById("array_4").innerHTML = person[1];

		document.getElementById("test_type_0").innerHTML = typeof object === "undefined";
		document.getElementById("test_type_1").innerHTML = typeof object === "null";
		document.getElementById("test_type_2").innerHTML = typeof object !== "undefined" && object !== null;

		</script>

<footer></footer>
<script type ="text/javascript" src="list.js" charset="utf-8"> </script>
</body>
</html>