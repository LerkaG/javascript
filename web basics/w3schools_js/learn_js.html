`<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<style>
		h1 {
			background-color: grey;
			width: 750px;
		}
		h2 {
			background-color: #FFCC99;
			width: 750px;
		}
		body {
			font-family: Arial;
			font-size: 16px;
		}
		h1, h2{
			margin-bottom: 4px;
			margin-top: 15px;
		}
		p {
			margin-top: 0px;
		}
		footer {
			margin-top: 300px;
		}
		pre {
			margin-top: 5px;
			margin-bottom: -15px;
  			line-height: 19px;
  			left: -120px;
  			position: relative;
		}
	</style>
	<h1>Вывод JavaScript</h1>
	методы JavaScript HTML: <br>
	<b>getElementById()</b> - document.getElementById("demo").innerHTML = "Hello JavaScript";

	<h2>Возможности отображения JavaScript</h2>
	innerHTML - Запись в элемент HTML. <br>
	document.write() - Запись в вывод HTML. <br>
	window.alert() - Запись в окно предупреждения. <br>
	console.log() - Запись в консоль браузера. <br>

	<h2>Использование innerHTML</h2>
	Чтобы получить доступ к элементу HTML, JavaScript может использовать <b>document.getElementById(id)</b>метод.
	id -Атрибут определяет HTML - элемент. <br> <b>innerHTML</b> Свойство определяет содержание HTML
	<br>ПРИМЕР: <br>
	<span> First page </span>
	<p>document.getElementById("demo").innerHTML = 5 + 6</p>
	<p id="demo"> </p>
	<script>
		document.getElementById("demo").innerHTML = 5 + 6;
	</script>

	<h2>Использование document.write()</h2>
	Удобно использовать в целях тестирования и должен использоваться только для тестирования
	<br>ПРИМЕР:
	<button type="button" onclick="document.write(5+6)">не нажимай </button> <!--после клика по кнопке, удаляется все содержимое на странице и остается это значение -->
	<script> document.write(5+62); // отображается значение  </script>

	<h2>Использование window.alert()</h2>
	Можно использовать окно предупреждения для отображения данных. Можно не использовать ключевое слово <b>window</b>
	<br>ПРИМЕР: <b>window.alert(5+6);</b> или <b>alert(5+6);</b>
	<!-- <script> window.alert(5+6);</script> -->

	<h2>Использование console.log ()</h2>
	В целях отладки можно вызвать <b>console.log();</b> метод в браузере для отображения данных.
	<br>ПРИМЕР: <b>console.log(5 + 6);</b>
	<script> console.log(5 + 6); </script>

	<h2> JavaScript Print</h2>
	В JavaScript нет объектов печати или методов печати. Нельзя получить доступ к устройствам вывода из JavaScript. <br>
	Единственным исключением является то, что вы можете вызвать <b>window.print()</b> метод в браузере для печати содержимого текущего окна.
	<br>ПРИМЕР: <button onclick="window.print()"> Print This page</button>

	<h1>Statements JS (Инструкции)</h1>
	<h2>Программы JavaScript</h2>
	Программа на JavaScript - это список программных операторов.

	<h2>Заявления JavaScript</h2>
	Операторы JavaScript состоят из: <b>Значения, операторов, выражений, ключевых слов и комментариев.</b> <br>
	Это утверждение говорит браузеру: написать <b>«Привет, Долли».</b> внутри элемента HTML с <b>id = "demo"</b>: <br>
	<b>document.getElementById("demo").innerHTML = "Hello Dolly.";</b>
	<br>ПРИМЕР: Hello, <b id="name"></b>!
	<script> document.getElementById("name").innerHTML = "pupkin"</script>

	<h2>Разрывы строк</h2>
	 document.getElementById("name").innerHTML =  <br>"pupkin";
	
	<h1> Синтаксис JS</h1>
	<h2>Значения JavaScript</h2>
	Синтаксис JavaScript определяет два типа значений: <b>фиксированные значения</b> и <b>значения переменных</b>. <br>
	<u>Фиксированные значения</u> называются <b>литералами</b>. <u>Значения переменных</u> называются <b>переменными</b>.

	<h2>Выражения JavaScript</h2>
	<b>Выражение</b> - это комбинация значений, переменных и операторов, которая вычисляет значение. <br>
	Вычисление называется оценкой. Например, 5 * 10 оценивает до 50

	<h2>Ключевые слова JavaScript</h2>
	Ключевые слова JavaScript используются для определения действий, которые необходимо выполнить.
	<b>var</b> Ключевое слово указывает браузеру, чтобы создать переменные

	<h2>Комментарии JavaScript</h2>
	однострочный - // <br>
	многострочный -  /* */

	<h2>Идентификаторы JavaScript</h2>
	Идентификаторы - это имена. Идентификаторы используются для именования переменных (и ключевых слов, и функций, и меток). <br>
	Первый символ должен быть <b>буквой</b>, или подчеркиванием <b>(_)</b>, или знаком доллара <b>($)</b>. Последующие символы могут быть <b>буквами, цифрами, подчеркиванием</b> или <b>знаком доллара</b>.

	<h2>Набор символов JavaScript</h2>
	JavaScript использует набор символов <b>Unicode</b>. Юникод охватывает (почти) все символы, знаки препинания и символы в мире.

	<h1>Переменные JS</h1>
	<h2>Идентификаторы JavaScript</h2>
	Все переменные JavaScript должны быть идентифицированы с уникальными именами они называются идентификаторами. <br>
	Зарезервированные слова (например, ключевые слова JavaScript) не могут использоваться в качестве имен

	<h1>JavaScript арифметика</h1>
	<h2>Oстаток</h2>
	Оператор модуля ( %) возвращает остаток от деления. 
	<br>ПРИМЕР: var x = 5;	var y = 3;	var z = x % y; <br>
	z = <b id="ostatok"></b>
	<script>
		var x = 5;
		var y = 3;
		var z = x % y;
		document.getElementById("ostatok").innerHTML = z;
	</script>

	<h2>Приращение</h2>
	Оператор приращения ( ++) увеличивает число.
	<br>ПРИМЕР: var x = 3; x++; var z = x; <br>
	z = <b id="double_plus"></b>
	<script>
		var x = 3;
		x++;
		var z = x;
		document.getElementById("double_plus").innerHTML = z;
	</script>

	<h2>Уменьшение номера</h2>
	Оператор декремента ( --) уменьшает число.
	<br>ПРИМЕР: var x = 3; x++; var z = x; <br>
	z = <b id="double_minus"></b>
	<script>
		var x = 3;
		x--;
		var z = x;
		document.getElementById("double_minus").innerHTML = z;
	</script>

	<h2>Возведение</h2>
	Оператор возведения в степень ( **) возводит первый операнд в степень второго операнда. <br>
	<b>х ** у</b> дает тот же результат, что и <b>Math.pow(x,y)</b>:
	<br>ПРИМЕР 1: var x = 5; var z = x ** 2; <br>
	z = <b id="stepen"> </b> <br>
	<br>ПРИМЕР 2: var x = 5; var y = Math.pow(x,2); <br>
	y = <b id="stepen_math"> </b>
	<script>
		var x = 5;
		var z = x ** 2;
		var y = Math.pow(x,2);
		document.getElementById("stepen").innerHTML = z;
		document.getElementById("stepen_math").innerHTML = y;
	</script>

	<h1>Операторы назначения JavaScript</h1>
	<h2>присваивание</h2>
	Оператор <b>+=</b> присваивания добавляет значение в переменную. 
	<br>ПРИМЕР: var x = 5; x += 5; x = <b id="plus"> </b> <br><br>
	Оператор <b>-=</b> вычитает значение из переменной.
	<br>ПРИМЕР: var y = 5; y -= 5; y = <b id="minus"> </b> <br><br>
	Оператор <b>*=</b> умножает переменную.
	<br>ПРИМЕР: var z = 5; z *= 5; z = <b id="umnishit"> </b> <br><br>
	Оператор <b>/=</b> делит переменную.
	<br>ПРИМЕР: var q = 5; q /= 5; q = <b id="delit"> </b> <br><br>
	Оператор <b>%=</b> присваивает остаток переменной.
	<br>ПРИМЕР: var w = 10; w %= 5; w = <b id="procent"> </b> <br><br>
	<script>
		var x = 5; x += 5;
		var y = 5; y -= 5;
		var z = 5; z *= 5;
		var q = 5; q /= 5;
		var w = 10; w %= 5;
		document.getElementById("plus").innerHTML = x;
		document.getElementById("minus").innerHTML = y;
		document.getElementById("umnishit").innerHTML = z;
		document.getElementById("delit").innerHTML = q;
		document.getElementById("procent").innerHTML = w;
	</script>

	<h1>Типы данных JavaScript</h1>
	Переменные JavaScript могут содержать много типов данных : числа, строки, объекты и многое другое
	<br>ПРИМЕР: <br>
	var length = 16; // <b>Number</b><br>
	var last_name = "Johson"; // <b>String</b><br>
	var x = {first_name: "John", last_name: "Doe" }; //	<b>Object</b><br>

	<h2>Концепция типов данных</h2>
	При добавлении числа и строки JavaScript будет обрабатывать число как строку.
	<br>ПРИМЕР: <br>
	var x = 16 + 4 + "Volvo"; //<b> 20Volvo //Number, string</b> <br>
	var x = "Volvo" + 16 + 4; // <b>Volvo164 //String</b> 

	<h2>Типы JavaScript являются динамическими</h2>
	JavaScript имеет динамические типы. Это означает, что одна и та же переменная может использоваться для хранения разных типов данных:
	<br>ПРИМЕР: <br>
	var x;      <b> // Now x is undefined</b> <br>
	x = 5;      <b> // Now x is a Number</b> <br>
	x = "John"; <b> // Now x is a String</b>

	<h2>Строки JavaScript</h2>
	Строки пишутся с одинарными или двойными кавычками. Можно использовать кавычки внутри строки, если они не соответствуют кавычкам, окружающим строку.
	<br>ПРИМЕР: <br>
	var carName1 = "Volvo XC60"; - <b id="carName1"></b><br>
	var carName2 = 'Volvo XC60'; - <b id="carName2"></b> <br>
	var answer2 = "He is called 'Johnny'"; - <b id="answer2"></b> <br> 
	var answer3 = 'He is called "Johnny"'; - <b id="answer3"></b>

	<script>
		var carName1 = "Volvo XC60";   
		var carName2 = 'Volvo XC60';  
		var answer2 = "He is called 'Johnny'"; 
		var answer3 = 'He is called "Johnny"';  
		document.getElementById("carName1").innerHTML = carName1;
		document.getElementById("carName2").innerHTML = carName2;
		document.getElementById("answer2").innerHTML = answer2;
		document.getElementById("answer3").innerHTML = answer3;
	</script>

	<h2>JavaScript Number</h2>
	JavaScript имеет только один тип чисел. Числа могут быть записаны с десятичными знаками или без них. Очень большие или очень маленькие числа могут быть написаны с научной (экспоненциальной) нотацией:
	<br>ПРИМЕР: <br>
	var y = 123e5; <u>// 12300000</u> <br> var z = 123e-5; <u> // 0.00123</u>
	
	<h2>JavaScript Booleans</h2>
	Логические значения могут иметь только два значения: true или false.
	<br>ПРИМЕР: <br>
	var x = 5;	var y = 5;	var z = 6; <br>
	(x == y); (x == z) <br>
	<b id="bool"></b>

	<script>
	var x = 5;
	var y = 5;
	var z = 6;
	document.getElementById("bool").innerHTML =
	(x == y) + "<br>" + (x == z);
	</script>

	<h2>Массивы JavaScript</h2>
	<br>ПРИМЕР: var cars = <b>["Saab", "Volvo", "BMW"];</b>

	<h2>JavaScript объекты</h2>
	Объекты JavaScript пишутся с помощью фигурных скобок {}. Свойства объекта записываются как пары имя: значение, разделенные запятыми.
	<br>ПРИМЕР: var person = <b>{firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"};</b>

	<h2>Тип оператора</h2>
	Можно использовать <b>typeof</b> оператор JavaScript, чтобы найти тип переменной JavaScript. <b>typeof</b> Оператор возвращает тип переменной или выражением
	<br>ПРИМЕР: <br>
	<b id="type"></b>
	<script>
		document.getElementById("type").innerHTML = 
		'typeof "" - ' + typeof "" + '<br> ' +
		'typeof "John" - ' + typeof "John" + '<br> ' +
		'typeof "John Doe" - ' + typeof "John Doe" + '<br> ' +
		'typeof 0 - ' + typeof 0 + "<br>" +
		'typeof 3.14 - ' + typeof 3.14 + "<br>" +
		'typeof (3 + 4) - ' + typeof (3 + 4) + "<br>"
	</script>

	<h2>undefined</h2>
	В JavaScript переменная без значения имеет тип и значение <b>undefined</b>. Любую переменную можно очистить, установив значение в <b>undefined</b> (тип тоже будет undefined)

	<h2>Пустые значения</h2>
	Пустая строка имеет допустимое значение и тип.
	<br>ПРИМЕР: var car = ""; <b>// The value is "", the typeof is "string"</b>

	<h2>null</h2>
	В JavaScript <b>null</b> это «ничего». Предполагается, что это нечто, чего не существует. В JavaScript тип данных <b>null</b> является объектом. <br>
	Можно очистить объект, установив его в <b>null</b> 

	<h2>Разница между undefined и null</h2>
	<b>undefined</b> и <b>null</b> равны по значению, но различаются по типу 
	<br>ПРИМЕР: <br>
	<p id="test"></p>
	<script>
		document.getElementById("test").innerHTML =
		"typeof undefined //" + "<b>" + typeof undefined + "</b><br>" +
		"typeof null //" + "<b>" + typeof null + "</b> <br><br>" +
		"null === undefined //" + "<b>" + (null === undefined) + "</b> <br>" +
		"null == undefined //" + "<b>" + (null == undefined) + "<b>";
	</script>

	<h2>Примитивные данные</h2>
	Примитивное значение данных - это одно простое значение данных без дополнительных свойств и методов. <b>typeof</b> Оператор может вернуть один из этих примитивных типов:
	<b>string, number, boolean, undefined</b>

	<h2>Комплексные данные</h2>
	<b>typeof</b> Оператор может возвращать одно из двух сложных типов: <b>function, object</b> <br>
	<b>typeof</b> Возвращает оператор <b>object</b> для <b>объектов, массивов, и null</b>, но НЕ возвращает для <u>функций</u>. <b>typeof</b> возвращает оператор <b>object</b> для<b> массивов</b>, так как в массивах JavaScript являются объектами.
	<br>ПРИМЕР: <br>
	<p id="data"></p>
	<script>
		document.getElementById("data").innerHTML = 
		"typeof {name:'dfdf', age:34} - " + "<b>" + typeof {name:"dfdf", age:34} + "</b><br>" +
		"typeof [1,2,3,4] - " + "<b>" + typeof [1,2,3,4] + "</b><br>" +
		"typeof function my_func(){} - " + "<b>" + typeof function my_func(){} + "</b>"
	</script>

	<h1>Функции JavaScript</h1>
	Функция JavaScript - это блок кода, предназначенный для выполнения конкретной задачи. Функция JavaScript выполняется, когда «что-то» ее вызывает.

	<h2>Синтаксис функции JavaScript</h2>
	Имена функций могут содержать <b>буквы, цифры, подчеркивания</b> и <b>знаки доллара</b> (те же правила, что и для переменных). <br>
	Круглые скобки в определении функции могут включать имена параметров, разделенные запятыми. <br>
	<b>Аргументы(параметры)</b> функции - это значения, полученные функцией при ее вызове. Внутри функции аргументы ведут себя как локальные переменные.
	<br>ПРИМЕР: <br>
	function name(parameter_1, parameter_2, parameter_3) { //code }

	<h2>Вызов функции</h2>
	Код внутри функции будет выполняться, когда «что-то» вызывает (вызывает) функцию: <br>
	<b>Когда происходит событие</b> (когда пользователь нажимает кнопку) <br>
	<b>Когда он вызывается</b> (вызывается) из кода JavaScript <br>
	<b>Автоматически</b> (самостоятельно вызывается)

	<h2>Возврат функции</h2>
	Когда JavaScript достигает <b>return</b> оператора, функция прекращает выполнение. Если функция была вызвана из оператора, JavaScript «вернется» для выполнения кода после вызова оператора.
	Функции часто вычисляют возвращаемое значение. Возвращаемое значение «возвращается» обратно «вызывающему»:
	<br>ПРИМЕР: <br>
	<pre>
		var x = my_function(4, 3);
		function my_function(a, b) {
		  return a * b;
		} 
		// x = <span id="function"></span>
	</pre> 
	<script>
		var x = my_function(4, 3);
		function my_function(a, b) {
			return a * b;
		}
		document.getElementById("function").innerHTML = x;
	</script>

	<h2>Функции, используемые в качестве переменных</h2>
	Функции можно использовать так же, как вы используете переменные, во всех типах формул, назначений и вычислений.
	<br>ПРИМЕР: <br>
	var text = "The temperature is " + new_function(23) + " Celsius"; <br>
	text //The temperature is <span id="new_function"> </span> Celsius
	<script>
		function new_function(temter) {
			return (5/9) * (temter-32);
		}
		document.getElementById("new_function").innerHTML = new_function(23);
	</script>

	<h2>Локальные переменные</h2>
	Переменные, объявленные в функции JavaScript, становятся ЛОКАЛЬНЫМИ для этой функции. Доступ к локальным переменным возможен только из функции. <br>
	Поскольку локальные переменные распознаются только внутри их функций, переменные с одинаковым именем могут использоваться в разных функциях. <br>
	Локальные переменные создаются при запуске функции и удаляются при ее завершении.
	<br>ПРИМЕР: <br>
	<pre>
		<i>//Not use car</i>
		function car_function () {
		  var car = "Volvo";
		  <i>//use car</i>
		}
		//Not use car
	</pre>

	<h1>JavaScript объекты</h1>
	Объекты - переменные, которые могут содержать много значений. Значения записываются как пары имя: значение (имя и значение разделяются двоеточием). <br>
	Объекты JavaScript - это контейнеры для именованных значений, называемых свойствами или методами.
	<br>ПРИМЕР: var car = { type: "Fiat", model:"500", color:"white" };

	<h2>Определение объекта</h2>
	Нужно определить (и создать) объект JavaScript с литералом объекта. Пробелы и разрывы строк не важны. Определение объекта может занимать несколько строк:
	<br>ПРИМЕР: <br>
	<pre>
		var person = {
		  first_name: "John",
		  last_name : "Doe",
		  age       : 50,
		  eye_color : "blue"
		};
	</pre>

	<h2>Свойства объекта</h2>
	Имя: значения пар в объектах JavaScript называются свойствами:
	<br>ПРИМЕР: <i>first_name</i> - <b>свойство</b>; <i>"John"</i> - <b>значение</b>.

	<h2>Доступ к свойствам объекта</h2>
	Можно получить доступ к свойствам объекта двумя способами: object_name.property_name; 2. object_name["property_name"];
	<br>ПРИМЕР: <br>
	person.first_name; person["last_name"]; = <b id="person_object"></b> 
	<script>
		var person = {
		  first_name: "John",
		  last_name : "Doe",
		  age       : 50,
		  eye_color : "blue"
		};
		document.getElementById("person_object").innerHTML = 
		person.first_name + " " + person["last_name"];
	</script>

	<h2>Методы объекта</h2>
	Объекты также могут иметь методы. Метод - это функция, хранящаяся как свойство. Методы - это действия, которые можно выполнять над объектами. Методы хранятся в свойствах как определения функций
	<br>ПРИМЕР: <br>
	<pre>
		var person = {
		  first_name: "John",
		  last_name : "Doe",
		  id        : 5566,
		  full_name : function () {
		    return this.first_name + " " + this.last_name;
		  }
		};
	</pre>

	<h2>Ключевое слово this</h2>
	В определении функции <b>this</b> относится к «владельцу» функции. В приведенном выше примере <b>this</b> это объект <b>person</b>, которому «принадлежит» <b>full_name</b> функция. <b>this.first_name</b> означает <b>first_name</b> свойство этого объекта.

	<h2>Доступ к объектным методам</h2>
	Можно получить доступ к объектному методу со следующим синтаксисом <i><b>object_name.method_name()</b></i>
	<br>ПРИМЕР: person.full_name(); = <b id="full_name"></b>
	<script>
		var person = {
		  first_name: "John",
		  last_name : "Doe",
		  id        : 5566,
		  full_name : function () {
		    return this.first_name + " " + this.last_name;
		  }
		};
		document.getElementById("full_name").innerHTML = person.full_name();
	</script>

	<h2>ЧЕГО НЕ СТОИТ ДЕЛАТЬ</h2>
	Не объявляйте <b>String, Number</b> и <b>Boolean</b> как объекты! Они усложняют код и замедляют скорость выполнения.
	Когда переменная JavaScript объявляется с ключевым словом <b>" new"</b>, переменная создается как объект.
	<br>ПРИМЕР как делать НЕЛЬЗЯ: <br>
	<pre>
		var x = new String();
		var y = new Number();
		var z = new Boolean();
	</pre>

	<h1>События JavaScript</h1>
	События HTML - это «вещи», которые происходят с элементами HTML. Когда JavaScript используется на страницах HTML, JavaScript может «реагировать» на эти события.

	<h2>HTML события</h2>
	HTML-событие может быть тем, что делает браузер, или тем, что делает пользователь. Несколько примеров событий HTML: <br>
	<i>1. HTML-страница закончила загрузку; 2. Поле ввода HTML было изменено; 3. Была нажата кнопка HTML.</i> <br>
	Когда происходят события, JavaScript позволяет выполнять код при обнаружении событий. HTML позволяет добавлять атрибуты обработчика событий с кодом JavaScript к элементам HTML.
	<br><u> ПРИМЕР с кавычками </u><br> 
	<span id="element_1"> </span>
	<br><u> ПРИМЕР с кнопкой </u><br> 
	<b>onclick</b> атрибут (с кодом) добавляется к <b>button</b> элементу: <br>
	<span id="element_2"> </span> <br>
	<button onclick="document.getElementById('btn').innerHTML = Date()"> The time is? </button>

	<script>
		document.getElementById("element_1").innerHTML = 
		"С одинарными кавычками: <b> < element event = 'some JS'> </b>" + "<br>" +
		'С двойными кавычками: <b> < element event = "some JS"> </b>' 

		document.getElementById("element_2").innerHTML = 
		"<b> < button onclick='document.getElementById('btn').innerHTML = Date()'> The time is? < /button>";
	</script>

	<h2>Общие события HTML</h2>
	Распространенные событий HTML: <br>
	<b>onchange</b>(по изменению) - HTML-элемент был изменен; <br>
	<b>onclick</b>(по щелчку) - Пользователь щелкает элемент HTML; <br>
	<b>onmouseover</b>(при наведении мыши) - Пользователь наводит указатель мыши на элемент HTML; <br>
	<b>onmouseout</b>(на мышке) - Пользователь отодвигает мышь от элемента HTML; <br>
	<b>onkeydown</b>(на ключ) - Пользователь нажимает клавишу клавиатуры; <br>
	<b>onload</b>(в процессе) - Браузер завершил загрузку страницы; 

	<h2>Что может сделать JavaScript?</h2>
	Обработчики событий могут использоваться для обработки и проверки ввода пользователя, действий пользователя и действий браузера. <br>
	Можно использовать много разных методов, чтобы позволить JavaScript работать с событиями

	<h1>Строки JavaScript</h1>
	Строки JavaScript используются для хранения и манипулирования текстом.

	<h2>Строки JavaScript</h2>
	Строка может быть пустой или содержать большое количество символов, заключенных в одинарные <b>' '</b> или двойные <b>" "</b> кавычки. <br>
	Можно использовать кавычки внутри строки, если они не соответствуют кавычкам, окружающим строку.
	<br> ПРИМЕР: <b>var man = "John 23 'alone'"</b>

	<h2>Длина строки</h2>
	Чтобы найти длину строки, можно воспользоваться встроенным length свойством:
	<br> ПРИМЕР:
	<pre>
		var txt = "bobocococ";
		txt.length; //<b id="length_txt"></b>
	</pre>
	
	<script>
		var txt = "bobocococ";
		document.getElementById("length_txt").innerHTML = txt.length;
	</script>

	<h2>Escape символ</h2>
	Экранирующий <b>\</b> символ обратной косой черты превращает специальные символы в строковые символы:
	<br> ПРИМЕР: <b id="escape"></b> <br>
	<script>
		document.getElementById("escape").innerHTML = "var x = \"We are the so-called \"Vikings\" from the north.\"";
	</script>

	Шесть других escape-последовательностей допустимы в JavaScript: <br>
	<b>\b</b> - Backspace;
	<b>\f</b> - Form Feed (Подача формы);
	<b>\n</b> - New Line;
	<b>\r</b> - Carriage Return;
	<b>\t</b> - Horizontal Tabulator;
	<b>\v</b> - Vertical Tabulator

	<h2>Ломка длинных строк кода</h2>
	Для читабельности лучше использовать не длиннее 80 символов строк кода. Если оператор JavaScript не помещается в одну строку, лучше всего его разбить после оператора<br>
	Можно разбить строку кода внутри текстовой строки с помощью одной обратной косой <b>\</b> черты, но этот способ поддерживают не все браузеры
	<br> ПРИМЕР:
	<pre>
		document.getElementById("string_test_1.0").innerHTML = "hello \
		dolly";
	</pre> 
	<b id="string_test_1.0"></b> <br>
	Более безопасный способ разбить строку, это использовать добавление строки:
	<pre>
		document.getElementById("string_test_1.1").innerHTML = "hello " +
		"dolly";
	</pre>
	<b id="string_test_1.1"></b> <br>
	
	<script>
		document.getElementById("string_test_1.0").innerHTML = "hello \
		dolly";
		document.getElementById("string_test_1.1").innerHTML = "hello " +
		"dolly";
	</script>

	<h2>Строки могут быть объектами</h2>
	Строки могут быть определены как объекты с ключевым словом <b>new</b>. Но лучше не создавать строки как объекты. Это замедляет скорость выполнения. Ключевое слово усложняет код. Это может привести к неожиданным результатам.
	<br> ПРИМЕР: 
	<pre> 
		<b>var x = "John";</b> // <span id="string_test_2.0"> </span>
		<b>var y = new String("John");</b> // <span id="string_test_2.1"> </span>
	</pre> <br>
		При использовании <b>==</b> оператора равные строки равны
	<pre>
		<b>(x == y)</b> // <span id="string_test_2.2"> </span> (because x and y have equal values)
	</pre> <br>
		При использовании <b>===</b> оператора одинаковые строки не равны, поскольку <b>===</b> оператор ожидает равенства как по типу, так и по значению
	<pre>
		<b>(x === y)</b> // <span id="string_test_2.3"> </span> (because x and y have different types - string and object)
	</pre> <br>
	Объекты нельзя сравнивать. Сравнение двух объектов JavaScript всегда вернет <b>false</b>.
	<pre>
		<b>var y = new String("John");</b>
		<b>var z = new String("John");</b> 
		<b>(y == z)</b> // <span id="string_test_2.4"> </span> (because x and y are different objects)
		<b>(y === z)</b> // <span id="string_test_2.5"> </span> (because x and y are different objects)
	</pre>

	<script>
		var x = "John";
		var y = new String("John");
		var z = new String("John");
		document.getElementById("string_test_2.0").innerHTML = (typeof x);
		document.getElementById("string_test_2.1").innerHTML = (typeof y);
		document.getElementById("string_test_2.2").innerHTML = (x == y);
		document.getElementById("string_test_2.3").innerHTML = (x === y);
		document.getElementById("string_test_2.4").innerHTML = (y == z);
		document.getElementById("string_test_2.5").innerHTML = (y === z);
	</script>

	<h1>Строковые методы JavaScript</h1>
	Строковые методы помогают работать со строками.

	<h2>Строковые методы и свойства</h2>
	Примитивные значения, такие как «Джон Доу», не могут иметь свойств или методов (потому что они не являются объектами). <br>
	Но с JavaScript методы и свойства также доступны для примитивных значений, потому что JavaScript обрабатывает примитивные значения как объекты при выполнении методов и свойств.

	<h2>Длина строки</h2>
	<b>length</b> - Свойство возвращает длину строки
	<br> ПРИМЕР: 
	<pre>
		var txt = "Please locate where 'locate' occurs!";
		txt.length; //<b id="string_txt_2.0"></b>
	</pre>
		
	<h2>В поисках строки в строке</h2>
	<b>indexOf()</b> - Метод возвращает индекс (положение) на first вхождения указанного текста в строке:
	<pre>
		txt.indexOf("locate"); //<b id="string_txt_2.1"></b>
	</pre>

	<b>lastIndexOf()</b> - Метод возвращает индекс последнего вхождения указанного текста в строке:
	<pre>
		txt.lastIndexOf("locate"); //<b id="string_txt_2.2"></b>
	</pre>

	Если текст не найден, то и <b>indexOf()</b>, и <b>lastIndexOf()</b> возвращают <b>-1</b>
	<pre>
		txt.lastIndexOf("John"); //<b id="string_txt_2.3"></b>
	</pre> <br>

	Оба метода принимают второй параметр в качестве начальной позиции для поиска. <br>
	Метод <b>lastIndexOf()</b> выполняет поиск в обратном направлении (от конца к началу), что означает: если второй параметр - 15 поиск начинается с позиции 15 и выполняется поиск в начале строки.
	<pre>
		txt.lastIndexOf("locate", 15); //<b id="string_txt_2.4"></b>
		txt.indexOf("locate", 15); //<b id="string_txt_2.5"></b> 
	</pre>

	<h2>Поиск строки в строке</h2>
	В <b>search()</b> методе ищет строку для указанного значения и возвращает позицию матча:
	<br> ПРИМЕР: <br>
	<pre>
		txt.search("locate"); //<b id="string_txt_2.6"></b>
	</pre>

	<h2>Разница между indexOf() и search()</h2>
	Два метода НЕ равны. Это различия: <br>
	<b>search()</b> Метод не может принимать второй аргумент позиции начала. <br>
	<b>indexOf()</b> Метод не может принимать мощные значения поиска (регулярные выражения).

	<h2>Извлечение струнных частей</h2>
	Есть 3 метода для извлечения части строки: <b>slice(<i>start, end</i>); substring(<i>start, end</i>); substr(<i>start, length</i>)</b>
	<h2> Метод slice() </h2>
	<b>slice()</b> извлекает часть строки и возвращает извлеченную часть в новой строке. Метод принимает 2 параметра: начальную позицию и конечную позицию (конечная позиция не включена). <br>Отрицательные позиции не работают в Internet Explorer 8 и более ранних версиях.
	<br> ПРИМЕР: <br>
	<pre>
		Вырезать часть строки из позиции 7 в позицию 12 (13-1):
		var str = "Apple, Banana, Kiwi";
		str.slice(7, 13); //<b id="string_txt_2.7"></b> 

		var txt_test = "I can eat bananas all day";
		txt_test.slice(10, -8); //<b id="test_slice_1"></b>	
		txt_test.slice(10, 17); //<b id="test_slice_2"></b>	

		Если параметр отрицательный, позиция отсчитывается от конца строки
		str.slice(-12, -6); //<b id="string_txt_2.8"></b> 

		Если опустить второй параметр, метод будет вырезать остальную часть строки:
		str.slice(7); //<b id="string_txt_2.9"></b> 
		str.slice(-12); //<b id="string_txt_2.10"></b> 
	</pre>

	<h2>Метод .substring()</h2>
	Разница <b>substring()</b> между <b>slice()</b>, в том, что <b>substring()</b> нельзя принимать отрицательные показатели.
	<br> ПРИМЕР: <br>
	<pre>
		str.substring(7, 12); //<b id="string_txt_2.11"></b> 
		str.substring(7); //<b id="string_txt_2.12"></b> 
	</pre>

	<h2>Метод .substr()</h2>
	Разница <b>substr()</b> между <b>slice()</b> в том, что второй параметр указывает длину извлеченной части.
	<br> ПРИМЕР: <br>
	<pre>
		str.substr(7, 12); //<b id="string_txt_2.13"></b> 
		str.substr(7, 6); //<b id="string_txt_2.14"></b> 
		str.substr(7); //<b id="string_txt_2.15"></b> 

		Если первый параметр отрицателен, позиция отсчитывается от конца строки.
		str.substr(-4); //<b id="string_txt_2.16"></b> 
	</pre>
	
	<h2>Замена содержимого строки</h2>
	<b>replace()</b> метод заменяет указанное значение с другим значением в строке. Метод не изменяет строку когда она вызвана, а возвращает новую строку. Метод чувствителен к регистру.
	<br> ПРИМЕР: <br>
	<pre>
		str.replace("Banana"); //<b id="string_txt_2.17"></b> 

		По умолчанию метод заменяет только первое совпадение:
		var str_2 = "Apple, Banana, Kiwi, Banana";
		str.replace("Banana", "Kiwi"); //<b id="string_txt_2.18"></b> 
	</pre>
	<pre>
		<b>< i id= 'replace_it'> "Apple, Banana, Kiwi "< /i> 
		< button onclick="func_replace()">Click me< /button>
		function func_replace() {
		   var str = document.getElementById("replace_it").innerHTML;
		   var txt = str.replace("Banana", "Orange");
		   document.getElementById("replace_it").innerHTML = txt;
		}</b>
		<i id="replace_it">"Apple, Banana, Kiwi"</i> <button onclick="func_replace()">Click me</button>

		Можно сделать не чувсвительность к регистру, использовавши регулярное выражение с <b>/i</b> флагом (нечувствительный):
		str.replace(/BANANA/i, "Kiwi"); //<b id="string_txt_2.19"></b> нечувствительный к регистру
		str.replace("BANANA", "Kiwi"); //<b id="string_txt_2.20"></b> чувствительный к регистру

		Чтобы заменить все совпадения, используйте регулярное выражение с <b>/g</b> флагом (глобальное совпадение):
		str_2.replace(/Banana/g, "Kiwi"); //<b id="string_txt_2.21"></b>
	</pre>

	<h2>Преобразование в верхний и нижний регистр</h2>
	<b>toUpperCase()</b> - Строка преобразуется в верхний регистр; <b>toLowerCase()</b> - Строка преобразуется в нижний регистр;
	<br> ПРИМЕР: <br>
	<pre>
		str.toLowerCase(); //<b id="string_txt_2.22"></b>
		str.toUpperCase(); //<b id="string_txt_2.23"></b>
	</pre>

	<h2>Метод .concat ()</h2>
	<b>concat()</b> - объединяет две или более строки. Этот метод может быть использован вместо оператора <b>плюс</b>. Все строковые методы возвращают новую строку. Строки не могут быть изменены, только заменены.
	<br> ПРИМЕР: <br>
	<pre>
		txt.concat(" ", str); //<b id="string_txt_2.24"></b>
		var new_txt = "It is New".concat(" ", "concat");
		new_txt.concat(" ", str); //<b id="string_txt_2.25"></b>
	</pre>

	<h2>Метод .trim ()</h2>
	<b>trim()</b> - метод удаляет пробельные символы с обеих сторон строки. Mетод не поддерживается в Internet Explorer 8 или ниже.
	<br> ПРИМЕР: <br>
	<pre>
		txt.trim(); //<b id="string_txt_2.26"></b>
	</pre>

	<h2>Извлечение строковых символов</h2>
	Есть 3 метода для извлечения строковых символов: <b>charAt(position), charCodeAt(position), Доступ к недвижимости [ ]</b> 
	<br> ПРИМЕР: <br>
	<pre>
		<b>charAt()</b> - Метод возвращает символ по указанному индексу (позиции) в строке. Если символ не найден, <b>charAt()</b> возвращает пустую строку.
		str.charAt(0); //<b id="string_txt_2.27"></b>
		str.charAt(22); //<b id="string_txt_2.28"></b>

		<b>charCodeAt()</b> - Метод возвращает юникод символа в заданном индексе в строке. Метод возвращает код UTF-16 (целое число от 0 до 65535).
		str.charCodeAt(0); //<b id="string_txt_2.29"></b>

		<b>[ ]</b> - доступ к свойству  для строк (ECMAScript 5 (2009)). Доступ к недвижимости может быть немного непредсказуемым:
		Это не работает в Internet Explorer 7 или более ранней версии;
		Это делает строки похожими на массивы (но это не так);
		Если символ не найден, <b>[]</b> возвращает <b>undefined</b>;
		Это только для чтения. str[0] = "B" не дает ошибок (но не работает!).
		str[0]; //<b id="string_txt_2.30"></b>
		str[0] = "B"; //<b id="string_txt_2.31"></b>
		str[22]; //<b id="string_txt_2.32"></b>
	</pre>

	<h2>Преобразование строки в массив</h2>
	Строка может быть преобразована в массив с помощью <b>split()</b> метода:
	<br> ПРИМЕР: 
	<pre>
		Если разделитель опущен, возвращаемый массив будет содержать всю строку в индексе [0]. 
		Если разделитель равен <b>""</b>, возвращаемый массив будет массивом из отдельных символов
		str.split(""); //<b id="string_txt_2.33"></b>

		str.split(","); //<b id="string_txt_2.34"></b>
		str.split("|"); //<b id="string_txt_2.35"></b>
		str.split(" "); //<b id="string_txt_2.36"></b>

		var num_test = "1,2,3,4,5,6,7";
		num_test.split(" "); //<b id="string_txt_2.37"></b>
		num_test.split(""); //<b id="string_txt_2.38"></b>
		num_test.split(","); //<b id="string_txt_2.39"></b>
		num_test.split("|"); //<b id="string_txt_2.40"></b>
		typeof num_test.split(" "); //<b id="string_txt_2.41"></b>
		typeof num_test; //<b id="string_txt_2.42"></b>
	</pre>

	<script>
		var txt = "  Please locate where 'locate' occurs!  ";
		var last_index_of_2 = txt.lastIndexOf("John");

		var str = "Apple, Banana, Kiwi";
		var str_2 = "Apple, Banana, Kiwi, Banana";
		var new_txt = "It is New".concat(" ", "concat");
		var num_test = "1,2,3,4,5,6,7";

		var txt_test = "I can eat bananas all day";

		document.getElementById("string_txt_2.0").innerHTML = txt.length;
		document.getElementById("string_txt_2.1").innerHTML = txt.indexOf("locate");
		document.getElementById("string_txt_2.2").innerHTML = txt.lastIndexOf("locate");
		document.getElementById("string_txt_2.3").innerHTML = last_index_of_2;
		document.getElementById("string_txt_2.4").innerHTML = txt.lastIndexOf("locate", 15);
		document.getElementById("string_txt_2.5").innerHTML = txt.indexOf("locate", 15);

		document.getElementById("string_txt_2.6").innerHTML = txt.search("locate");

		document.getElementById("string_txt_2.7").innerHTML = str.slice(7, 13);
		document.getElementById("string_txt_2.8").innerHTML = str.slice(-12, -6);
		document.getElementById("string_txt_2.9").innerHTML = str.slice(7);
		document.getElementById("string_txt_2.10").innerHTML = str.slice(-12);
		document.getElementById("test_slice_1").innerHTML = txt_test.slice(10, -8);
		document.getElementById("test_slice_2").innerHTML = txt_test.slice(10, 17);

		document.getElementById("string_txt_2.11").innerHTML = str.substring(7, 12);
		document.getElementById("string_txt_2.12").innerHTML = str.substring(7);

		document.getElementById("string_txt_2.13").innerHTML = str.substr(7, 12);
		document.getElementById("string_txt_2.14").innerHTML = str.substr(7, 6);
		document.getElementById("string_txt_2.15").innerHTML = str.substr(7);
		document.getElementById("string_txt_2.16").innerHTML = str.substr(-4);

		document.getElementById("string_txt_2.17").innerHTML = str.replace("Banana");
		document.getElementById("string_txt_2.18").innerHTML = str_2.replace("Banana", "Kiwi");
		document.getElementById("string_txt_2.19").innerHTML = str.replace(/BANANA/i, "Kiwi");
		document.getElementById("string_txt_2.20").innerHTML = str.replace("BANANA", "Kiwi");
		document.getElementById("string_txt_2.21").innerHTML = str_2.replace(/Banana/g, "Kiwi");

		document.getElementById("string_txt_2.22").innerHTML = str.toLowerCase();
		document.getElementById("string_txt_2.23").innerHTML = str.toUpperCase();

		document.getElementById("string_txt_2.24").innerHTML = txt.concat(" ", str);
		document.getElementById("string_txt_2.25").innerHTML = new_txt.concat(" ", str);

		document.getElementById("string_txt_2.26").innerHTML = txt.trim();

		document.getElementById("string_txt_2.27").innerHTML = str.charAt(0);
		document.getElementById("string_txt_2.28").innerHTML = str.charAt(22);
		document.getElementById("string_txt_2.29").innerHTML = str.charCodeAt(0);
		document.getElementById("string_txt_2.30").innerHTML = str[0];
		document.getElementById("string_txt_2.31").innerHTML = str[0] = "B";
		document.getElementById("string_txt_2.32").innerHTML = str[22];

		document.getElementById("string_txt_2.33").innerHTML = str.split("");
		document.getElementById("string_txt_2.34").innerHTML = str.split(",");
		document.getElementById("string_txt_2.35").innerHTML = str.split("|");
		document.getElementById("string_txt_2.36").innerHTML = str.split(" ");

		document.getElementById("string_txt_2.37").innerHTML = num_test.split(" ");
		document.getElementById("string_txt_2.38").innerHTML = num_test.split("");
		document.getElementById("string_txt_2.39").innerHTML = num_test.split(",");
		document.getElementById("string_txt_2.40").innerHTML = num_test.split("|");
		document.getElementById("string_txt_2.41").innerHTML = typeof num_test.split(" ");
		document.getElementById("string_txt_2.42").innerHTML = typeof num_test;

		function func_replace() {
			var str = document.getElementById("replace_it").innerHTML;
			var txt = str.replace("Banana", "Orange");
			document.getElementById("replace_it").innerHTML = txt;
		}
	</script>

	<h1>JavaScript Numbers</h1>
	JavaScript имеет только один тип чисел. Числа могут быть написаны с или без десятичных знаков. Очень большие или очень маленькие числа могут быть написаны с научной (показательной) нотацией
	<br>ПРИМЕР<br>
	<pre>
		var x = 123e5; //<b id="num_1"></b>
		var y = 123e-5; //<b id="num_2"></b>
	</pre>

	<h2>Числа JavaScript всегда 64-битные с плавающей точкой</h2>
	JavaScript <b>не</b> определяет различные типы чисел, такие как целые, короткие, длинные, с плавающей точкой и т. Д. <br>
	Числа JavaScript всегда хранятся в виде <b>чисел с плавающей запятой двойной точности</b> в соответствии с международным стандартом <b>IEEE 754.</b><br>
	Этот формат хранит числа в <b>64 битах</b>, где число (дробь) хранится в 52 битах <b>с 0 по 51</b>, показатель степени в 11 битах <b>с 52 по 62 </b>и знак в 1 бите (63)

	<h2>Точность</h2>
	Целые числа (числа без точки или обозначения периода) имеют точность до 15 цифр. Максимальное количество десятичных знаков равно <b>17</b>
	<br>ПРИМЕР<br>
	<pre>
		x = 999999999999999; // <b id="num_3"></b>
		y = 9999999999999999; // <b id="num_4"></b>

		Арифметика с плавающей запятой не всегда точна на 100%!
		var z = 0.2 + 0.1; // <b id="num_5"></b>

		Чтобы решить эту проблему,  помогает умножить и разделить
		var q = (0.2 * 10 + 0.1 * 10) /10; // <b id="num_6"></b>
	</pre>

	<h2>Добавление чисел и строк</h2>
	JavaScript использует оператор <b>+</b> как для <b>сложения</b>, так и для <b></b>объединения.
	<br>ПРИМЕР:<br>
	<pre>
		var w = 20 + 20;   // <b id="num_7"> </b> 
		var t = 20;        // <b id="num_10"> </b>
		var y = "20";      // <b id="num_11"> </b>

		Если добавить число и строку или наоборот, то результатом будет <b>конкатенация</b> строк:
		var e = "20" + 20; // <b id="num_8"> </b>
		var r = 20 + "20"; // <b id="num_9"> </b>
		var u = t + t + y; // <b id="num_12"> </b>
		var i = y + t + t; // <b id="num_13"> </b>
	</pre>

	<h2>Числовые строки</h2>
	Строки JavaScript могут иметь числовое содержимое. JavaScript попытается преобразовать строки в числа во всех числовых операциях:
	<br>ПРИМЕР
	<pre>
		t = "10";
		t / y; // <b id="num_14"> </b>    работает
		t * y; // <b id="num_15"> </b>  работает
		t - y; // <b id="num_16"> </b>    работает
		t + y; // <b id="num_17"> </b> не работает
	</pre>

	<h2>NaN (Not a Number) - не число</h2>
	<b>NaN</b> является зарезервированным словом JavaScript, указывающим, что число не является допустимым числом. <br>
	Попытка выполнить арифметику с нечисловой строкой приведет к <b>NaN</b> (не числу), а если строка содержит числовое значение, результатом будет число. <b>NaN</b> возвращает <b>number</b>
	<br>ПРИМЕР
	<pre>
		h = "Apple";
		h / y // <b id="num_18"> </b> 
		t / h; // <b id="num_19"> </b> 

		Можно использовать глобальную функцию JavaScript, <b>isNaN()</b> чтобы узнать, является ли значение числом:
		var b = t / h;
		isNaN(t / h); // <b id="num_20"> </b> 
		isNaN(b); // <b id="num_21"> </b> 
		isNaN(t * y) + " " + t * y; // <b id="num_22"> </b> 

		Если использовать <b>NaN</b> в математической операции, результат также будет <b>NaN</b> или результатом может быть конкатенация:
		var m = NaN;
		m + "Apple"; // <b id="num_23"> </b> 
		m + 5; // <b id="num_24"> </b> 
		m + "5"; // <b id="num_25"> </b> 
		typeof m; // <b id="num_26"> </b> 
	</pre>

	<h2>Infinity</h2>
	<b>Infinity</b>(или <b>-Infinity</b>) - это значение, которое JavaScript вернет, если вычислить число за пределами максимально возможного числа.
	<br>ПРИМЕР
	<pre>
		var my_number = 2;
		while (my_number != Infinity) {
		   my_number = my_number * my_number;
		}
		my_number; // <b id="num_infinity"> </b>

		var my_number_2 = 2;
		var num_test = "";
		while (my_number_2 != Infinity) {
			my_number_2 = my_number_2 * my_number_2;
			num_test = num_test + my_number_2;
		}
		num_test; // <b id="num_infinity_2"> </b>
		my_number_2; // <b id="num_infinity_3"> </b>

		Деление на 0 (ноль) также генерирует Infinity
		4 / 0 // <b id="num_infinity_4"> </b>

		<b>Infinity</b> это число возвращает <b>number</b>.
		typeof Infinity //<b id="num_infinity_5"> </b>
	</pre>

	<h2>Шестнадцатеричный</h2>
	JavaScript интерпретирует числовые константы как шестнадцатеричные, если им предшествует 0x.  <br>
	Нельзя писать число с начальным нулем (например, 07). Некоторые версии JavaScript интерпретируют числа как восьмеричные, если они написаны с начальным нулем.
	<br>ПРИМЕР
	<pre>
		0x333; // <b id="num_sixteen_1"> </b>

		По умолчанию, JavaScript отображает числа в качестве основы 10 знаков после запятой.
		Можно использовать <b>toString()</b> метод для вывода чисел от базы 2 до базы 36.
		var t = 20;
		t.toString(16); // <b id="num_string_1"></b>    16. 
		t.toString(10); // <b id="num_string_2"></b>    10. 
		t.toString(8);  // <b id="num_string_3"></b>     8. 
		t.toString(2);  // <b id="num_string_4"></b>  2.
	</pre>

	<h2>Числа могут быть объектами</h2>
	Обычно числа JavaScript являются примитивными значениями, созданными из литералов. Но числа также могут быть определены как <i>объекты</i> с ключевым словом <b>new</b>. <br>
	Не нужно создавать объекты <b>Number</b>. Это замедляет скорость выполнения. Ключевое слово усложняет код. Это может привести к неожиданным результатам: <b>new</b>
	<br>ПРИМЕР
	<pre>
		var i = 123; // литерал
		var p = new Number(123); // объект
		i; // <b id="num_no_object"> </b> 
		p; // <b id="num_object"> </b> 

		При использовании <b>==</b> оператора равные числа равны:
		i == p; // <b id="num_no_object_2"> </b>

		При использовании <b>===</b>оператора равные числа не равны, поскольку <b>===</b> оператор ожидает равенства как по типу, так и по значению.
		i === p; // <b id="num_no_object_3"> </b>

		Объекты нельзя сравнивать. Сравнение двух объектов JavaScript всегда вернет <b>false</b>.
		var z = new Number(123);
		z === p; // <b id="num_no_object_4"> </b>
		z == p; // <b id="num_no_object_5"> </b>
	</pre>

	<script>
		var x = 123e5;
		var y = 123e-5;
		document.getElementById("num_1").innerHTML = x;
		document.getElementById("num_2").innerHTML = y;

		x = 999999999999999; 
		y = 9999999999999999; 
		var z = 0.2 + 0.1;
		var q = (0.2 * 10 + 0.1 * 10) /10;

		var w = 20 + 20;
		var e = "20" + 20;
		var r = 20 + "20";
		var t = 20;
		var y = "20";
		var u = t + t + y;
		var i = y + t + t;
		document.getElementById("num_3").innerHTML = x;
		document.getElementById("num_4").innerHTML = y;
		document.getElementById("num_5").innerHTML = z;
		document.getElementById("num_6").innerHTML = q;

		document.getElementById("num_7").innerHTML = w + " type - " + typeof w;
		document.getElementById("num_8").innerHTML = e + " type - " + typeof e;
		document.getElementById("num_9").innerHTML = r + " type - " + typeof r;
		document.getElementById("num_10").innerHTML = t + " type - " + typeof t;
		document.getElementById("num_11").innerHTML = y + " type - " + typeof y;
		document.getElementById("num_12").innerHTML = u + " type - " + typeof u;
		document.getElementById("num_13").innerHTML = i + " type - " + typeof i;

		h = "Apple";
		var b = t / h;
		var m = NaN;
		document.getElementById("num_14").innerHTML = t / y;
		document.getElementById("num_15").innerHTML = t * y;
		document.getElementById("num_16").innerHTML = t - y;
		document.getElementById("num_17").innerHTML = t + y;

		document.getElementById("num_18").innerHTML = h / y;
		document.getElementById("num_19").innerHTML = t / h;
		document.getElementById("num_20").innerHTML = isNaN(t / h);
		document.getElementById("num_21").innerHTML = isNaN(b);
		document.getElementById("num_22").innerHTML = isNaN(t * y) + " " + t * y;

		document.getElementById("num_23").innerHTML = m + "Apple" + " type: " + typeof (m + h);
		document.getElementById("num_24").innerHTML = m + 5 + " type: " + typeof (m + y);
		document.getElementById("num_25").innerHTML = m + "5" + " type: " + typeof (m + t);
		document.getElementById("num_26").innerHTML = typeof m;

		var my_number = 2;

		while (my_number != Infinity) {
			my_number = my_number * my_number;
		};
		document.getElementById("num_infinity").innerHTML = my_number;

		var my_number_2 = 2;
		var num_test = "";
		while (my_number_2 != Infinity) {
			my_number_2 = my_number_2 * my_number_2;
			num_test = num_test + my_number_2 + "   ";
		}
		document.getElementById("num_infinity_2").innerHTML = num_test;
		document.getElementById("num_infinity_3").innerHTML = my_number_2;

		document.getElementById("num_infinity_4").innerHTML = 4 / 0;
		document.getElementById("num_infinity_5").innerHTML = typeof Infinity;

		document.getElementById("num_sixteen_1").innerHTML = 0x333;

		document.getElementById("num_string_1").innerHTML = t.toString(16);
		document.getElementById("num_string_2").innerHTML = t.toString(10);
		document.getElementById("num_string_3").innerHTML = t.toString(8);
		document.getElementById("num_string_4").innerHTML = t.toString(2);

		var i = 123; 
		var p = new Number(123);
		document.getElementById("num_no_object").innerHTML = i + "; type: " + typeof i;
		document.getElementById("num_object").innerHTML = p + "; type: " + typeof p;
		document.getElementById("num_no_object_2").innerHTML = (p == i) + "; type: " + typeof (p == i);
		document.getElementById("num_no_object_3").innerHTML = (p === i) + "; type: " + typeof (p === i);

		var z = new Number(123);
		document.getElementById("num_no_object_4").innerHTML = (z === p) + "; type: " + typeof (z === p);
		document.getElementById("num_no_object_5").innerHTML = (z == p) + "; type: " + typeof (z == p);
	</script>

	<h1>Числовые методы</h1>
	Числовые методы помогут работать с числами.

	<h2>Числовые методы и свойства</h2>
	Примитивные значения (например, <b>3.14</b> или <b>2014</b>) не могут иметь свойств и методов, потому что <i>они не являются объектами</i>. <br>
	Но с JavaScript <b>методы</b> и <b>свойства</b> также доступны <b>для примитивных значений</b>, потому что JavaScript <i>обрабатывает примитивные значения как объекты при выполнении методов и свойств.</i>

	<h2>Метод toString()</h2>
	<b>toString()</b> - Метод возвращает число в виде строки. <br>
	Все числовые методы могут быть использованы для любого типа чисел (литералов, переменных или выражений):
	<br>ПРИМЕР
	<pre>
		var x = 123;
		x.toString();          // <b id="num_method_1"> </b>
		(123).toString();      // <b id="num_method_2"> </b>
		(100 + 23).toString(); // <b id="num_method_3"> </b>
	</pre>

	<h2>Метод toExponential()</h2>
	<b>toExponential()</b> - возвращает строку, число которой округлено и записано с использованием экспоненциальной записи. Параметр определяет количество символов за десятичной точкой.
	<br>ПРИМЕР
	<pre>
		var x = 9.656;
		x.toExponential(2); // <b id="num_method_4"> </b>
		x.toExponential(4); // <b id="num_method_5"> </b>
		x.toExponential(6); // <b id="num_method_6"> </b>

		Параметр является необязательным. Если не указать это, JavaScript не будет округлять число.
		x.toExponential();  // <b id="num_method_7"> </b>
	</pre>

	<script>
		var x = 123;
		document.getElementById("num_method_1").innerHTML = x.toString() + " type:" + typeof x.toString();
		document.getElementById("num_method_2").innerHTML = (123).toString() + " type:" + typeof (123).toString();
		document.getElementById("num_method_3").innerHTML = (100 + 23).toString() + " type:" + typeof (100 + 23).toString();

		var x = 9.656;
		document.getElementById("num_method_4").innerHTML = x.toExponential(2);
		document.getElementById("num_method_5").innerHTML = x.toExponential(4);
		document.getElementById("num_method_6").innerHTML = x.toExponential(6);
		document.getElementById("num_method_7").innerHTML = x.toExponential();
	</script>
	


<footer></footer>
</body>
</html>